#!/usr/bin/env python3
import sys
import subprocess
import re
from datetime import datetime

# display help
def help():
    print("usage: ./version-up.py [-r|--release] [-a|--alpha] [-b|--beta] [-c|--release-candidate]")
    print("                      [-m|--major] [-i|--minor] [-p|--patch] [-e|--revision] [-g|--git-revision]")
    print("                      [--stay] [--default] [--help]")
    print("")
    print("Switches:")
    print("  --release           switch stage to release, no suffix, -r")
    print("  --alpha             switch stage to alpha, -a")
    print("  --beta              switch stage to beta, -b")
    print("  --release-candidate switch stage to rc, -c")
    print("  --major             increment MAJOR version part, -m")
    print("  --minor             increment MINOR version part, -i")
    print("  --patch             increment PATCH version part, -p")
    print("  --revision          increment REVISION version part, -e")
    print("  --git-revision      use git revision number as a revision part, -g")
    print("  --stay              compose version.properties but do not do any increments, -s")
    print("  --default           increment last found part of version, keeping the stage. Increment applied up to MINOR part.")
    print("  --apply             run GIT command to apply version upgrade")
    print("")
    print("Version: MAJOR.MINOR[.PATCH[.REVISION]][-STAGE]")
    print("")
    print("Reference:")
    print("  http://semver.org/")
    print("")
    print("Versions priority:")
    print("  1.0.0-alpha < 1.0.0-beta < 1.0.0-rc < 1.0.0")
    sys.exit(0)

# get highest version tag for all branches
def highest_tag():
    tags = subprocess.check_output(["git", "tag", "--list"], stderr=subprocess.DEVNULL).decode().split("\n")
    tags = [tag for tag in tags if re.match(r'^\d+\.\d+(\.\d+)*(-(alpha|beta|rc))*$', tag)]
    if not tags:
        return None
    sorted_tags = sorted(tags, key=lambda t: list(map(int, t.split("."))))
    return sorted_tags[-1]

# extract current branch name
def current_branch():
    branch = subprocess.check_output(["git", "rev-parse", "--abbrev-ref", "HEAD"]).decode().strip()
    if branch.startswith("heads/"):
        branch = branch.split("/")[1]
    return branch

# get latest/head commit hash number
def head_hash():
    commit_hash = subprocess.check_output(["git", "rev-parse", "--verify", "HEAD"]).decode().strip()
    return commit_hash

# extract tag commit hash code, tag name provided by argument
def tag_hash(tag):
    try:
      tag_hash = subprocess.check_output(["git", "log", "-1", "--format=format:%H", tag], stderr=subprocess.DEVNULL).decode().strip()
    except:
      return None
    return tag_hash

# get latest tag in specified branch
def latest_tag():
    tag = subprocess.check_output(["git", "describe", "--tags", "--abbrev=0"], stderr=subprocess.DEVNULL).decode().strip()
    return tag

# get latest revision number
def latest_revision():
    rev = subprocess.check_output(["git", "rev-list", "--count", "HEAD"], stderr=subprocess.DEVNULL).decode().strip()
    return rev

# parse last found tag, extract its parts
def parse_last(parts):
    position = len(parts) - 1

    if "-" in parts[position]:
        sub_parts = parts[position].split("-")
        parts[position] = sub_parts[0]
        parts.append(sub_parts[1].lower())

    else:
        parts.append("")

# increment REVISION part, don't touch STAGE
def increment_revision(parts):
    parts[3] = str(int(parts[3]) + 1)

# increment PATCH part, reset all other lower PARTS, don't touch STAGE
def increment_patch(parts):
    parts[2] = str(int(parts[2]) + 1)
    parts[3] = "0"

# increment MINOR part, reset all other lower PARTS, don't touch STAGE
def increment_minor(parts):
    parts[1] = str(int(parts[1]) + 1)
    parts[2] = "0"
    parts[3] = "0"

# increment MAJOR part, reset all other lower PARTS, don't touch STAGE
def increment_major(parts):
    parts[0] = str(int(parts[0]) + 1)
    parts[1] = "0"
    parts[2] = "0"
    parts[3] = "0"

# increment the number only of last found PART: REVISION --> PATCH --> MINOR. don't touch STAGE
def increment_last_found(parts):
    if parts[3] == "0":
        if parts[2] == "0":
            increment_minor(parts)
        else:
            increment_patch(parts)
    else:
        increment_revision(parts)
    if parts[4] != "":
        parts.append("")

# compose version from PARTS
def compose(parts):

    major = parts[0]
    minor = "." + parts[1]
    patch = "." + parts[2]
    revision = "." + parts[3]
    suffix = "-" + parts[4]

    if len(patch) == 1:
        patch = ""
    if len(revision) == 1:
        revision = ""
    if parts[3] == "0":
        revision = ""
    if revision == "" and parts[2] == "0":
        patch = ""
    elif revision != "" and patch == "":
        patch = ".0"

    if len(suffix) == 1:
        suffix = ""

    return major + minor + patch + revision + suffix

# initial version used for repository without tags
INIT_VERSION = "0.0.0-alpha.0"

# do GIT data extracting
tag = latest_tag()
revision = latest_revision()
branch = current_branch()
top_tag = highest_tag()
tag_hash_val = tag_hash(tag)
head_hash_val = head_hash()

# if tag and branch commit hashes are different, than print info about that
if tag_hash_val == head_hash_val:
    print("Tag", tag, "and HEAD are aligned. We will stay on the TAG version.\n")
    no_args_value = "--stay"
else:
    pattern = r"(^[0-9]+\.[0-9]+(\.[0-9]+)*(-(alpha|beta|rc))*$)|(alpha|beta|rc)"
    if re.match(pattern, branch):
        print(f"Detected version {tag} in branch '", branch, "'. We will auto-increment the last version PART.\n")
        no_args_value = "--default"
    else:
        print("Detected branch name '", branch, "' that does not match the version pattern. We will increase MINOR.\n")
        no_args_value = "--minor"

parts = tag.split(".")

parse_last(parts)

if len(sys.argv) == 1 or (len(sys.argv) == 2 and '--apply' in sys.argv):
    sys.argv.append(no_args_value)

# parse input parameters
for i in sys.argv[1:]:
    if i in ["-a", "--alpha"]:
        parts[4] = "alpha"
    elif i in ["-b", "--beta"]:
        parts[4] = "beta"
    elif i in ["-c", "--release-candidate"]:
        parts[4] = "rc"
    elif i in ["-r", "--release"]:
        parts[4] = ""
    elif i in ["-p", "--patch"]:
        increment_patch(parts)
    elif i in ["-e", "--revision"]:
        increment_revision(parts)
    elif i in ["-g", "--git-revision"]:
        parts[3] = revision
    elif i in ["-i", "--minor"]:
        increment_minor(parts)
    elif i == "--default":
        increment_last_found(parts)
    elif i in ["-m", "--major"]:
        increment_major(parts)
    elif i in ["-s", "--stay"]:
        pass

# print proposed version
proposed_tag = compose(parts)
subprocess.run(["pnpm", "-w", "release", proposed_tag])


# compose version override file
if tag == INIT_VERSION:
    tag = "0.0.0-alpha.0"
version_file = "version.properties"

with open(version_file, "w") as f:
    f.write(f"# {datetime.now()}\n")
    f.write(f"snapshot.version={proposed_tag}\n")
    f.write(f"snapshot.lasttag={tag}\n")
    f.write(f"snapshot.revision={revision}\n")
    f.write(f"snapshot.hightag={top_tag}\n")
    f.write(f"snapshot.branch={branch}\n")
    f.write("# end of file\n")

# apply the changes if needed
do_apply = "--apply" in sys.argv

proposed_hash=tag_hash(proposed_tag)

if do_apply:
    print("Applying git repository version up... no push, only local tag assignment!\n")
    subprocess.run(["git", "tag", proposed_tag])
    subprocess.run(["git", "push", proposed_tag])

    # confirm that tag applied
    log_output = subprocess.check_output(
        ["git", "--no-pager", "log", "--pretty=format:%h%x09%Cblue%cr%Cgreen%x09%an%Creset%x09%s%Cred%d%Creset", "-n", "2", "--date=short"]
    ).decode().strip()
    log_output = "\n".join([f"  {line}" for line in log_output.split("\n")])
    print(log_output, "\n")
else:
  print("To apply changes manually execute the command(s):")
  print("\033[90m")
  print(f"  git tag {proposed_tag}")
  print("\033[0m")

if proposed_hash and do_apply:
    print("\033[31mERROR:\033[0m ")
    print("\033[31mERROR:\033[0m Found conflict with existing tag \033[32m", proposed_tag, f"\033[0m / {tag_hash_val}")
    print("\033[31mERROR:\033[0m Only manual resolving is possible now.")
    print("\033[31mERROR:\033[0m ")
    print("\033[31mERROR:\033[0m To Resolve try to add --revision or --patch modifier.")
    print("\033[31mERROR:\033[0m ")
    print("")

# compose version override file
if tag == INIT_VERSION:
    tag = "0.0.0-alpha.0"

version_file = "version.properties"

with open(version_file, "w") as f:
    f.write(f"# {datetime.now()}\n")
    f.write(f"snapshot.version={proposed_tag}\n")
    f.write(f"snapshot.lasttag={tag}\n")
    f.write(f"snapshot.revision={revision}\n")
    f.write(f"snapshot.hightag={top_tag}\n")
    f.write(f"snapshot.branch={branch}\n")
    f.write("# end of file\n")
